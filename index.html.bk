<!DOCTYPE html>
<html lang="en">
  <head>
    <title>TreatJS: Higher-Order Contracts for JavaScript</title>

    <link rel="stylesheet" type="text/css" href="Xstyle.css" media="screen" />




  </head>
  <body>
    <h1>TreatJS: Higher-Order Contracts for JavaScript</h1>

    <p>TreatJS version 1.2.4</p>

    <p>
    <textarea id="input" name="input" style="width: 100%;" rows="30" ></textarea>
    </p>

    <p>
    <button id="run" name="run" value="run">Run</button>
    </p>

    <p>
    <textarea id="output" name="output" style="width: 100%;" rows="10" readonly="readonly"></textarea>
    </p>

    <!-- TreatJS -->
    <script src="lib/lib_padding.js"></script>

    <script src="src/out.js"></script>
    <script src="src/debugger.js"></script>
    <script src="src/treat.js"></script>
    <script src="src/treat.system.js"></script>
    <script src="src/treat.base.js"></script>
    <script src="src/treat.config.js"></script>

    <script src="src/core/treat.violation.js"></script>
    <script src="src/core/treat.sandbox.js"></script>
    <script src="src/core/treat.logic.js"></script>
    <script src="src/core/treat.callback.js"></script>
    <script src="src/core/treat.map.js"></script>
    <script src="src/core/treat.contract.js"></script>
    <script src="src/core/treat.assert.js"></script>
    <script src="src/treat.canonicalize.js"></script>

    <script src="src/treat.convenience.js"></script>
    <script src="test/contracts.js"></script>

    <script>

      var target = {};

      target.Any = TreatJS.BaseContract(function(arg) {
        return true; 
      },"Any");



      /* TypeOf-Contracts */

      target.typeOfNumber = TreatJS.BaseContract(function(arg) {
        return ((typeof arg) === "number");
      },"typeOfNumber");

      target.typeOfString = TreatJS.BaseContract(function(arg) {
        return ((typeof arg) === "string");
      },"typeOfString");

      target.typeOfBoolean = TreatJS.BaseContract(function(arg) {
        return ((typeof arg) === "boolean");
      },"typeOfBoolean");

      target.typeOfObject =  TreatJS.BaseContract(function(arg) {
        return ((typeof arg) === "object");
      },"typeOfObject");

      target.typeOfFunction = TreatJS.BaseContract(function(arg) {
        return ((typeof arg) === "function");
      },"typeOfFunction");

      target.typeOfUndefined = TreatJS.BaseContract(function(arg) {
        return ((typeof arg) === "undefined");
      },"typeOfUndefined");


      /* InstanceOf-Contracts */

      target.instanceOfTarget =  TreatJS.BaseContract(function(arg) {
        return (arg instanceof target); 
      },"instanceOfTarget");



      target.instanceOfObject =  TreatJS.With({Object:Object}, TreatJS.BaseContract(function(arg) {
        return (arg instanceof Object); 
      },"instanceOfObject"));

      target.instanceOfFunction =  TreatJS.With({Function:Function}, TreatJS.BaseContract(function(arg) {
        return (arg instanceof Function); 
      },"instanceOfFunction"));

      target.instanceOfArray = TreatJS.With({Array:Array}, TreatJS.BaseContract(function(arg) {
        return (arg instanceof Array);
      },"instanceOfArray"));

      target.instanceOfBoolean = TreatJS.With({Boolean:Boolean}, TreatJS.BaseContract(function(arg) {
        return (arg instanceof Boolean);
      },"instanceOfBoolean"));

      target.instanceOfDate = TreatJS.With({Date:Date}, TreatJS.BaseContract(function(arg) {
        return (arg instanceof Date);
      },"instanceOfDate"));

      target.instanceOfIterator = TreatJS.With({Iterator:Iterator}, TreatJS.BaseContract(function(arg) {
        return (arg instanceof Iterator);
      },"instanceOfIterator"));

      target.instanceOfNumber = TreatJS.With({Number:Number}, TreatJS.BaseContract(function(arg) {
        return (arg instanceof Number);
      },"instanceOfNumber"));

      target.instanceOfString = TreatJS.With({String:String}, TreatJS.BaseContract(function(arg) {
        return (arg instanceof String);
      },"instanceOfString"));

      target.instanceOfRegExp = TreatJS.With({RegExp:RegExp}, TreatJS.BaseContract(function(arg) {
        return (arg instanceof RegExp);
      },"instanceOfRegExp"));

      target.instanceOfError = TreatJS.With({Error:Error}, TreatJS.BaseContract(function(arg) {
        return (arg instanceof Error);
      },"instanceOfError"));



      /* Is-Contracts */

      target.isNaN= TreatJS.BaseContract(function(arg) {
        return (arg === NaN);
      },"isNaN");

      target.isUndefined = TreatJS.BaseContract(function(arg) {
        return (arg === undefined);
      },"isUndefined");

      target.isNull = TreatJS.BaseContract(function(arg) {
        return (arg === "boolean");
      },"isNull");

      target.isTrue = TreatJS.BaseContract(function(arg) {
        return (arg) ? true : false; 
      },"isTrue");

      target.isFalse = TreatJS.BaseContract(function(arg) {
        return (arg) ? false : true; 
      },"isFalse");



      /* Is-Contracts */

      target.isPrimitiveValue = TreatJS.BaseContract(function(arg) {
        return (target !== Object(target)) ? true : false; 
      },"isPrimitiveValue");

      target.isNativeFunction = TreatJS.BaseContract(function(arg) {
        return (Function.prototype.toString.apply(func).indexOf('[native code]') > -1); 
      },"isNativeFunction");
    </script>

    <script>
      // set configuration
      TreatJS.configure({
        assertion:true,
        membrabe:true,
        decompile:true,
        canonicalize: true 
      });

      // set verbose
      TreatJS.verbose({
        assert:false,
        sandbox:false
      });

      // clean output
      function cleanup() {
        tjsout = "";
        exit = false;
        document.getElementById('output').value = "";
      }

      // extend string to output
      function putstr(str) {
        document.getElementById('output').value += str;
      }

      // TreatJS print outpur
      var tjsout = "";
      function print(str) {
        tjsout += (str+"\n");
      }

      // TreatJS exit command
      var exit = false;
      function quit() {
        exit = true;
      }

      // handler
      var handler = {
        has : function(target, name) {
          if(!(name in target)) throw new Error("ReferenceError: "+name+" is not defined")
          else return true;
        },
        get : function(target, name, receiver) {
          return target[name];
        }
      }

      // target
      TreatJS.export(target)

      // set bingings
      var Contract = TreatJS.build();
      target.C = Contract;
      target.Contract = Contract;
      target.TreatJS = TreatJS;

      // global object
      var global = Proxy(target, handler);

      // evaluate input string
      function evaluate(input) {
        var result = "";

        try {
          result = eval("with(global) { \n" + input + "\n }");
          } catch (e) {
          result = e.toString();
        }
        putstr((exit) ? tjsout : result);
      }

    </script>

    <script>

      (function() {

        // set on click action
        var run = document.getElementById('run');
        run.onclick = function() {

          // check if proxy exists
          if(!Proxy) {
            var err = "Error!"
            document.getElementById('output').value = err;
            return;
          }

          // clean up
          cleanup();

          // evaluate input
          var input =  document.getElementById('input').value;
          evaluate(input);
        }
      })();
    </script>

  </body>
</html>
